/**
 * CNXT-Connector
 * The CNXT-Connector is developed by Rodenstock GmbH to integrate data from measurement devices such as DNEye<sup>®</sup> Scanner, Rodenstock Fundus Scanner, and ImpressionIST<sup>®</sup> into 3rd party applications as well as into several applications of Rodenstock such as WinFit, Rodenstock Consulting etc. If you have any feedback then please feel free to contact us via email. Copyright © Rodenstock GmbH 2020
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: cnxt@rodenstock.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.2.3.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "B2BOptic.h"

namespace com {
namespace rodenstock {
namespace cnxt {
namespace connector {
namespace client {
namespace model {




B2BOptic::B2BOptic()
{
    m_Xml = utility::conversions::to_string_t("");
    m_XmlIsSet = false;
    m_Json = utility::conversions::to_string_t("");
    m_JsonIsSet = false;
}

B2BOptic::~B2BOptic()
{
}

void B2BOptic::validate()
{
    // TODO: implement validation
}

web::json::value B2BOptic::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_XmlIsSet)
    {
        val[utility::conversions::to_string_t("xml")] = ModelBase::toJson(m_Xml);
    }
    if(m_JsonIsSet)
    {
        val[utility::conversions::to_string_t("json")] = ModelBase::toJson(m_Json);
    }

    return val;
}

void B2BOptic::fromJson(const web::json::value& val)
{
    if(val.has_field(utility::conversions::to_string_t("xml")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("xml"));
        if(!fieldValue.is_null())
        {
            setXml(ModelBase::stringFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("json")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("json"));
        if(!fieldValue.is_null())
        {
            setJson(ModelBase::stringFromJson(fieldValue));
        }
    }
}

void B2BOptic::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(m_XmlIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("xml"), m_Xml));
    }
    if(m_JsonIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("json"), m_Json));
    }
}

void B2BOptic::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("xml")))
    {
        setXml(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("xml"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("json")))
    {
        setJson(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("json"))));
    }
}

utility::string_t B2BOptic::getXml() const
{
    return m_Xml;
}

void B2BOptic::setXml(const utility::string_t& value)
{
    m_Xml = value;
    m_XmlIsSet = true;
}

bool B2BOptic::xmlIsSet() const
{
    return m_XmlIsSet;
}

void B2BOptic::unsetXml()
{
    m_XmlIsSet = false;
}

utility::string_t B2BOptic::getJson() const
{
    return m_Json;
}

void B2BOptic::setJson(const utility::string_t& value)
{
    m_Json = value;
    m_JsonIsSet = true;
}

bool B2BOptic::jsonIsSet() const
{
    return m_JsonIsSet;
}

void B2BOptic::unsetJson()
{
    m_JsonIsSet = false;
}

}
}
}
}
}
}


