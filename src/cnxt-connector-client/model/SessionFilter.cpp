/**
 * CNXT-Connector
 * The CNXT-Connector is developed by Rodenstock GmbH to integrate data from measurement devices such as DNEye<sup>®</sup> Scanner, Rodenstock Fundus Scanner, and ImpressionIST<sup>®</sup> into 3rd party applications as well as into several applications of Rodenstock such as WinFit, Rodenstock Consulting etc. If you have any feedback then please feel free to contact us via email. Copyright © Rodenstock GmbH 2020
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: cnxt@rodenstock.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.2.3.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "SessionFilter.h"

namespace com {
namespace rodenstock {
namespace cnxt {
namespace connector {
namespace client {
namespace model {




SessionFilter::SessionFilter()
{
    m_ExternalId = utility::conversions::to_string_t("");
    m_ExternalIdIsSet = false;
    m_CreatedAfter = utility::datetime();
    m_CreatedAfterIsSet = false;
    m_UpdatedAfter = utility::datetime();
    m_UpdatedAfterIsSet = false;
    m_StateIsSet = false;
}

SessionFilter::~SessionFilter()
{
}

void SessionFilter::validate()
{
    // TODO: implement validation
}

web::json::value SessionFilter::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_ExternalIdIsSet)
    {
        val[utility::conversions::to_string_t("externalId")] = ModelBase::toJson(m_ExternalId);
    }
    if(m_CreatedAfterIsSet)
    {
        val[utility::conversions::to_string_t("createdAfter")] = ModelBase::toJson(m_CreatedAfter);
    }
    if(m_UpdatedAfterIsSet)
    {
        val[utility::conversions::to_string_t("updatedAfter")] = ModelBase::toJson(m_UpdatedAfter);
    }
    if(m_StateIsSet)
    {
        val[utility::conversions::to_string_t("state")] = ModelBase::toJson(m_State);
    }

    return val;
}

void SessionFilter::fromJson(const web::json::value& val)
{
    if(val.has_field(utility::conversions::to_string_t("externalId")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("externalId"));
        if(!fieldValue.is_null())
        {
            setExternalId(ModelBase::stringFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("createdAfter")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("createdAfter"));
        if(!fieldValue.is_null())
        {
            setCreatedAfter(ModelBase::dateFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("updatedAfter")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("updatedAfter"));
        if(!fieldValue.is_null())
        {
            setUpdatedAfter(ModelBase::dateFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("state")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("state"));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<SessionState> newItem(new SessionState());
            newItem->fromJson(fieldValue);
            setState( newItem );
        }
    }
}

void SessionFilter::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(m_ExternalIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("externalId"), m_ExternalId));
    }
    if(m_CreatedAfterIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("createdAfter"), m_CreatedAfter));
    }
    if(m_UpdatedAfterIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("updatedAfter"), m_UpdatedAfter));
    }
    if(m_StateIsSet)
    {
        if (m_State.get())
        {
            m_State->toMultipart(multipart, utility::conversions::to_string_t("state."));
        }
    }
}

void SessionFilter::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("externalId")))
    {
        setExternalId(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("externalId"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("createdAfter")))
    {
        setCreatedAfter(ModelBase::dateFromHttpContent(multipart->getContent(utility::conversions::to_string_t("createdAfter"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("updatedAfter")))
    {
        setUpdatedAfter(ModelBase::dateFromHttpContent(multipart->getContent(utility::conversions::to_string_t("updatedAfter"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("state")))
    {
        if(multipart->hasContent(utility::conversions::to_string_t("state")))
        {
            std::shared_ptr<SessionState> newItem(new SessionState());
            newItem->fromMultiPart(multipart, utility::conversions::to_string_t("state."));
            setState( newItem );
        }
    }
}

utility::string_t SessionFilter::getExternalId() const
{
    return m_ExternalId;
}

void SessionFilter::setExternalId(const utility::string_t& value)
{
    m_ExternalId = value;
    m_ExternalIdIsSet = true;
}

bool SessionFilter::externalIdIsSet() const
{
    return m_ExternalIdIsSet;
}

void SessionFilter::unsetExternalId()
{
    m_ExternalIdIsSet = false;
}

utility::datetime SessionFilter::getCreatedAfter() const
{
    return m_CreatedAfter;
}

void SessionFilter::setCreatedAfter(const utility::datetime& value)
{
    m_CreatedAfter = value;
    m_CreatedAfterIsSet = true;
}

bool SessionFilter::createdAfterIsSet() const
{
    return m_CreatedAfterIsSet;
}

void SessionFilter::unsetCreatedAfter()
{
    m_CreatedAfterIsSet = false;
}

utility::datetime SessionFilter::getUpdatedAfter() const
{
    return m_UpdatedAfter;
}

void SessionFilter::setUpdatedAfter(const utility::datetime& value)
{
    m_UpdatedAfter = value;
    m_UpdatedAfterIsSet = true;
}

bool SessionFilter::updatedAfterIsSet() const
{
    return m_UpdatedAfterIsSet;
}

void SessionFilter::unsetUpdatedAfter()
{
    m_UpdatedAfterIsSet = false;
}

std::shared_ptr<SessionState> SessionFilter::getState() const
{
    return m_State;
}

void SessionFilter::setState(const std::shared_ptr<SessionState>& value)
{
    m_State = value;
    m_StateIsSet = true;
}

bool SessionFilter::stateIsSet() const
{
    return m_StateIsSet;
}

void SessionFilter::unsetState()
{
    m_StateIsSet = false;
}

}
}
}
}
}
}


