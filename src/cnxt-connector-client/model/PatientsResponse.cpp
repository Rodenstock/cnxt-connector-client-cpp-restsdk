/**
 * CNXT-Connector
 * The CNXT-Connector is developed by Rodenstock GmbH to integrate data from measurement devices such as DNEye<sup>®</sup> Scanner, Rodenstock Fundus Scanner, and ImpressionIST<sup>®</sup> into 3rd party applications as well as into several applications of Rodenstock such as WinFit, Rodenstock Consulting etc. If you have any feedback then please feel free to contact us via email. Copyright © Rodenstock GmbH 2020
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: cnxt@rodenstock.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.2.3.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "PatientsResponse.h"

namespace com {
namespace rodenstock {
namespace cnxt {
namespace connector {
namespace client {
namespace model {




PatientsResponse::PatientsResponse()
{
    m_PatientsIsSet = false;
    m__linksIsSet = false;
    m_PageInfoIsSet = false;
}

PatientsResponse::~PatientsResponse()
{
}

void PatientsResponse::validate()
{
    // TODO: implement validation
}

web::json::value PatientsResponse::toJson() const
{
    web::json::value val = web::json::value::object();

    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Patients )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[utility::conversions::to_string_t("patients")] = web::json::value::array(jsonArray);
        }
    }
    if(m__linksIsSet)
    {
        val[utility::conversions::to_string_t("_links")] = ModelBase::toJson(m__links);
    }
    if(m_PageInfoIsSet)
    {
        val[utility::conversions::to_string_t("pageInfo")] = ModelBase::toJson(m_PageInfo);
    }

    return val;
}

void PatientsResponse::fromJson(const web::json::value& val)
{
    {
        m_Patients.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(utility::conversions::to_string_t("patients")))
        {
        for( auto& item : val.at(utility::conversions::to_string_t("patients")).as_array() )
        {
            if(item.is_null())
            {
                m_Patients.push_back( std::shared_ptr<PatientResponse>(nullptr) );
            }
            else
            {
                std::shared_ptr<PatientResponse> newItem(new PatientResponse());
                newItem->fromJson(item);
                m_Patients.push_back( newItem );
            }
        }
        }
    }
    if(val.has_field(utility::conversions::to_string_t("_links")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("_links"));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<PaginationLink> newItem(new PaginationLink());
            newItem->fromJson(fieldValue);
            setLinks( newItem );
        }
    }
    if(val.has_field(utility::conversions::to_string_t("pageInfo")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("pageInfo"));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<PageInfo> newItem(new PageInfo());
            newItem->fromJson(fieldValue);
            setPageInfo( newItem );
        }
    }
}

void PatientsResponse::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Patients )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("patients"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
        }
    }
    if(m__linksIsSet)
    {
        if (m__links.get())
        {
            m__links->toMultipart(multipart, utility::conversions::to_string_t("_links."));
        }
    }
    if(m_PageInfoIsSet)
    {
        if (m_PageInfo.get())
        {
            m_PageInfo->toMultipart(multipart, utility::conversions::to_string_t("pageInfo."));
        }
    }
}

void PatientsResponse::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    {
        m_Patients.clear();
        if(multipart->hasContent(utility::conversions::to_string_t("patients")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("patients"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_Patients.push_back( std::shared_ptr<PatientResponse>(nullptr) );
            }
            else
            {
                std::shared_ptr<PatientResponse> newItem(new PatientResponse());
                newItem->fromJson(item);
                m_Patients.push_back( newItem );
            }
        }
        }
    }
    if(multipart->hasContent(utility::conversions::to_string_t("_links")))
    {
        if(multipart->hasContent(utility::conversions::to_string_t("_links")))
        {
            std::shared_ptr<PaginationLink> newItem(new PaginationLink());
            newItem->fromMultiPart(multipart, utility::conversions::to_string_t("_links."));
            setLinks( newItem );
        }
    }
    if(multipart->hasContent(utility::conversions::to_string_t("pageInfo")))
    {
        if(multipart->hasContent(utility::conversions::to_string_t("pageInfo")))
        {
            std::shared_ptr<PageInfo> newItem(new PageInfo());
            newItem->fromMultiPart(multipart, utility::conversions::to_string_t("pageInfo."));
            setPageInfo( newItem );
        }
    }
}

std::vector<std::shared_ptr<PatientResponse>>& PatientsResponse::getPatients()
{
    return m_Patients;
}

void PatientsResponse::setPatients(const std::vector<std::shared_ptr<PatientResponse>>& value)
{
    m_Patients = value;
    m_PatientsIsSet = true;
}

bool PatientsResponse::patientsIsSet() const
{
    return m_PatientsIsSet;
}

void PatientsResponse::unsetPatients()
{
    m_PatientsIsSet = false;
}

std::shared_ptr<PaginationLink> PatientsResponse::getLinks() const
{
    return m__links;
}

void PatientsResponse::setLinks(const std::shared_ptr<PaginationLink>& value)
{
    m__links = value;
    m__linksIsSet = true;
}

bool PatientsResponse::linksIsSet() const
{
    return m__linksIsSet;
}

void PatientsResponse::unset_links()
{
    m__linksIsSet = false;
}

std::shared_ptr<PageInfo> PatientsResponse::getPageInfo() const
{
    return m_PageInfo;
}

void PatientsResponse::setPageInfo(const std::shared_ptr<PageInfo>& value)
{
    m_PageInfo = value;
    m_PageInfoIsSet = true;
}

bool PatientsResponse::pageInfoIsSet() const
{
    return m_PageInfoIsSet;
}

void PatientsResponse::unsetPageInfo()
{
    m_PageInfoIsSet = false;
}

}
}
}
}
}
}


