# C++ API client

The CNXT-Connector is developed by Rodenstock GmbH to integrate data from measurement devices such as DNEye<sup>®</sup> Scanner, Rodenstock Fundus Scanner, and ImpressionIST<sup>®</sup> into 3rd party applications as well as into several applications of Rodenstock such as WinFit, Rodenstock Consulting etc. If you have any feedback then please feel free to contact us via email. Copyright © Rodenstock GmbH 2020

## Overview
This API client was generated by the [OpenAPI Generator](https://openapi-generator.tech) project. By using the [OpenAPI spec](https://openapis.org) from a remote server, you can easily generate an API client.

- API version: 1.0.0
- Package version: 1.0.0
- Build package: org.openapitools.codegen.languages.CppRestSdkClientCodegen
For more information, please visit [https://www.rodenstock.com/cnxt](https://www.rodenstock.com/cnxt).
The API is available via [http://connector.develop.cnxt.dtr01.rodenstock.com:8080/api/](http://connector.develop.cnxt.dtr01.rodenstock.com:8080/api/).

- API namespace: com.rodenstock.cnxt.connector.client.api
- Model namespace: com.rodenstock.cnxt.connector.client.model

## Dependencies

- [CPPRESTSDK](https://www.nuget.org/api/v2/package/cpprestsdk.v141/2.10.12.1) - 2.10.12.1 or later
- [BOOST](https://www.nuget.org/api/v2/package/boost/1.71.0) - 1.71.0 or later

NOTE: All dependencies will be automatically downloaded via CMake.

## Installation

### Prerequisites

Install [CMAKE](https://cmake.org/download/).

### Build on Windows via CMake UI

Run CMake app to generate the build (solution and project) files

- Press Browse Source... and select the directory where your source code files are located
- Press Browse Build... and select the directory where the binaries should generated
- Select you favorite Visual Studio Version (2015, 2017, 2019)
- Press Configure to update and display new values in red
- Press Generate to generate selected build (solution and project files) files

### Build on Windows via CMake in command prompt

Run CMake in command prompt to generate the build (solution and project) files

```sh
# build library for 32-bit (x86) platform
cmake -S ./src/cnxt-connector-client/ -B ./ -DCMAKE_CONFIGURATION_TYPES=Debug;Release -DCMAKE_GENERATOR_PLATFORM=x86 -DCMAKE_INSTALL_PREFIX="%PROGRAMFILES%/Rodenstock/cnxt-connector-client"

# build library for 64-bit (x64) platform
cmake -S ./src/cnxt-connector-client/ -B ./ -DCMAKE_CONFIGURATION_TYPES=Debug;Release -DCMAKE_GENERATOR_PLATFORM=x64 -DCMAKE_INSTALL_PREFIX="%PROGRAMFILES%/Rodenstock/cnxt-connector-client"
```

Then open the generated Visual Studio solution, and use the namespaces:

### Build on Windows with Visual Studio (VS2015, VS2017, VS2019)

- Right click on folder containing source code
- Select 'Open in visual studio'
- Once visual studio opens, CMake should show up in top menu bar.
- Select CMake > Build All.

*Note: If the CMake menu item doesn't show up in Visual Studio, CMake 
for Visual Studio must be installed. In this case, open the 'Visual Studio 
Installer' application. Select 'modify' Visual Studio 2017. Make sure 
'Desktop Development with C++' is installed, and specifically that 'Visual 
C++ tools for CMake' is selected in the 'Installation Details' section.
Please not that Visual Studio 2019 has built in support for CMake.

Also be sure to review the CMakeLists.txt file. Edits are likely required.*

```cpp
using namespace com::rodenstock::cnxt::connector::client::api;
using namespace com::rodenstock::cnxt::connector::client::model;

```

## Getting Started

```cpp
// ConsoleApplication.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <vector>
#include <boost/optional.hpp>

#include "ApiClient.h"

#include "api/PatientsApi.h"
#include "api/SessionsApi.h"

#include "ApiConfiguration.h"

#include "model/Patient.h"
#include "model/PatientResponse.h"
#include "model/PatientsResponse.h"
#include "model/PatientLink.h"
#include "model/Session.h"
#include "model/SessionResponse.h"
#include "model/SessionsResponse.h"
#include "model/SessionLink.h"

#include <windows.h>
#include <string>
#include <iostream>

using namespace std;
using namespace com::rodenstock::cnxt::connector::client::api;
using namespace com::rodenstock::cnxt::connector::client::model;

std::wstring readUnicodeFile(const std::wstring& filePath)
{
	std::wifstream wif(filePath);
	std::wstringstream wss;
	wss << wif.rdbuf();
	std::wstring wstr = wss.str();
	return wstr;
}

std::wstring getCurrentWorkingDirectory()
{
	wchar_t buffer[MAX_PATH];
	GetModuleFileName(NULL, buffer, MAX_PATH);
	std::wstring::size_type pos = std::wstring(buffer).find_last_of(L"\\/");
	return std::wstring(buffer).substr(0, pos);
}

int main()
{
	std::shared_ptr<ApiConfiguration> apiConfiguration(new ApiConfiguration());
	
	// Used for development purposes
	apiConfiguration.get()->setBaseUrl(utility::string_t(L"http://connector.develop.cnxt.dtr01.rodenstock.com:8080/api/"));
	
	// Used for production purposes (CNXT-Connector API is only reachable on http://localhost:8280/api/)
	//apiConfiguration.get()->setBaseUrl(utility::string_t(L"http://localhost:8280/api/"));

	std::shared_ptr<ApiClient> apiClient(new ApiClient(apiConfiguration));

	std::shared_ptr<PatientsApi> patientsApi = std::shared_ptr<PatientsApi>(new PatientsApi(apiClient));

	boost::optional<std::vector<utility::string_t>> patientIncludes = std::vector<utility::string_t>{ L"session", L"latestSessionId", L"latestSessionUpdate" };

	patientsApi->getPatients(25, boost::optional<utility::string_t>(), boost::optional<std::shared_ptr<PatientFilter>>(), boost::optional<std::vector<utility::string_t>>(), patientIncludes).then([=](pplx::task<std::shared_ptr<PatientsResponse>> patientsResponse) {
		try {
			for (auto const& patient : patientsResponse.get()->getPatients()) {
				patientsApi->getPatient(patient.get()->getId(), patientIncludes).then([=](pplx::task<std::shared_ptr<PatientResponse>> patientResponse) {
					try {
						std::wstring id = std::wstring(patientResponse.get()->getId().c_str());
						std::wstring firstName = std::wstring(patientResponse.get()->getFirstName().c_str());
						std::wstring lastName = std::wstring(patientResponse.get()->getLastName().c_str());

						std::wstring dateOfBirth(L"");
						if (patientResponse.get()->getDateOfBirth().is_initialized())
						{
							dateOfBirth = patientResponse.get()->getDateOfBirth().to_string().c_str();
						}

						std::wcout << L"Id: " << patientResponse.get()->getId().c_str() << std::endl
							<< L"Title: " << patientResponse.get()->getTitle().c_str() << std::endl
							<< L"FirstName: " << patientResponse.get()->getFirstName().c_str() << std::endl
							<< L"LastName: " << patientResponse.get()->getLastName().c_str() << std::endl
							<< L"DateOfBirth: " << dateOfBirth << std::endl
							<< L"Gender: " << patientResponse.get()->getGender().c_str() << std::endl
							<< L"CreatedAt: " << patientResponse.get()->getCreatedAt().to_string().c_str() << std::endl
							<< L"UpdatedAt: " << patientResponse.get()->getUpdatedAt().to_string().c_str() << std::endl;

						std::vector<std::shared_ptr<Session>> sessions = patientResponse.get()->getSessions();

						for (auto const& session : sessions) {
							std::wstring id = std::wstring(session.get()->getId().c_str());
						}
					}
					catch (const std::exception & e) {
						std::cout << "getPatient() exception: " << e.what() << '\n';
					}
					}).wait();
			}
		}
		catch (const std::exception & e) {
			std::cout << "getPatients() exception: " << e.what() << '\n';
		}
		}).wait();

		std::shared_ptr<SessionsApi> sessionsApi = std::shared_ptr<SessionsApi>(new SessionsApi(apiClient));

		boost::optional<std::vector<utility::string_t>> sessionIncludes = std::vector<utility::string_t>{ L"patient", L"b2boptic" };

		sessionsApi->getSessions(25, boost::optional<utility::string_t>(), boost::optional<std::shared_ptr<SessionFilter>>(), boost::optional<std::vector<utility::string_t>>(), sessionIncludes).then([=](pplx::task<std::shared_ptr<SessionsResponse>> sessionsResponse) {
			try {
				for (auto const& session : sessionsResponse.get()->getSessions()) {
					sessionsApi->getSession(session.get()->getId(), sessionIncludes).then([=](pplx::task<std::shared_ptr<SessionResponse>> sessionResponse) {
						try {
							std::wstring id = std::wstring(sessionResponse.get()->getId().c_str());
							std::wstring name = std::wstring(sessionResponse.get()->getName().c_str());
							std::wstring state = std::wstring(sessionResponse.get()->getState().c_str());

							std::wstring createdAt(L"");
							if (sessionResponse.get()->getCreatedAt().is_initialized())
							{
								createdAt = sessionResponse.get()->getCreatedAt().to_string().c_str();
							}

							std::wstring updatedAt(L"");
							if (sessionResponse.get()->getUpdatedAt().is_initialized())
							{
								updatedAt = sessionResponse.get()->getUpdatedAt().to_string().c_str();
							}

							std::wcout << L"Id: " << sessionResponse.get()->getId().c_str() << std::endl
								<< L"ExternalId: " << sessionResponse.get()->getExternalId().c_str() << std::endl
								<< L"Name: " << sessionResponse.get()->getName().c_str() << std::endl
								<< L"State: " << sessionResponse.get()->getName().c_str() << std::endl
								<< L"PatientId: " << sessionResponse.get()->getPatientId().c_str() << std::endl
								<< L"CreatedAt: " << createdAt << std::endl
								<< L"UpdatedAt: " << updatedAt << std::endl;

							// Get patient which is assigned to the defined session
							std::shared_ptr<Patient> patient = sessionResponse.get()->getPatient();

							// Get session data as B2BOptic XML document
							sessionsApi->getB2bOptic(sessionResponse.get()->getId()).then([=](pplx::task<std::wstring> b2bOpticData) {
								std::wstring xml = std::wstring(b2bOpticData.get());
								}).wait();
						}
						catch (const std::exception & e) {
							std::cout << "getSession() exception: " << e.what() << '\n';
						}
						}).wait();
				}
			}
			catch (const std::exception & e) {
				std::cout << "getSessions() exception: " << e.what() << '\n';
			}
			}).wait();

			std::wstring b2bOpticFile2 = readUnicodeFile(getCurrentWorkingDirectory() + L"/B2BOptic_Sample2.xml");

			// Import B2BOptic XML document into an existing session
			sessionsApi->importB2BOpticAsNewSession(b2bOpticFile2, boost::optional<utility::string_t>(L"OPEN")).then([=](pplx::task<std::vector<utility::string_t>> response) {
				std::vector<utility::string_t> ids = response.get();
				}).wait();

			std::wstring b2bOpticFile3 = readUnicodeFile(getCurrentWorkingDirectory() + L"/B2BOptic_Sample3.xml");

			// Import B2BOptic XML document into an existing session
			sessionsApi->importB2BOptic(L"a0eac5fa-695b-4c65-b2e1-5e36bf76d4cb", b2bOpticFile2, boost::optional<utility::string_t>(L"OPEN")).then([=](pplx::task<std::vector<utility::string_t>> response) {
				std::vector<utility::string_t> ids = response.get();
				}).wait();

			return 0;
}
}
```

## Documentation for API Endpoints

All URIs are relative to *http://connector.develop.cnxt.dtr01.rodenstock.com:8080/api*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*PatientsApi* | [**GetPatient**](docs/PatientsApi.md#getpatient) | **GET** /patients/{id} | Retrieves a patient by ID.
*PatientsApi* | [**GetPatients**](docs/PatientsApi.md#getpatients) | **GET** /patients | Retrieves a list of patients. The endpoint implements pagination by using links. Additionally, it is possible to filter by parameters such as lastName, firstName, createdAfter, updatedAfter or to sort ascending or descending.
*SessionsApi* | [**GetB2bOptic**](docs/SessionsApi.md#getb2boptic) | **GET** /sessions/{id}/b2boptic | Retrieves a session by ID represented as B2BOptic XML document.
*SessionsApi* | [**GetSession**](docs/SessionsApi.md#getsession) | **GET** /sessions/{id} | Retrieves a session by ID.
*SessionsApi* | [**GetSessions**](docs/SessionsApi.md#getsessions) | **GET** /sessions | Retrieves a list of sessions. This endpoint implements pagination by using links. Additionally, it is possible to filter by parameters such as externalId, createdAfter, updatedAfter or to sort ascending or descending.
*SessionsApi* | [**ImportB2BOptic**](docs/SessionsApi.md#importb2boptic) | **PUT** /sessions/{id} | Imports a B2BOptic XML document defined by the session ID. This B2BOptic XML document is assigned to an existing session via the defined session ID or assigned to this patient as a new session via the specified id of the session and specified first name, last name, or date of birth of the patient.
*SessionsApi* | [**ImportB2BOpticAsNewSession**](docs/SessionsApi.md#importb2bopticasnewsession) | **POST** /sessions | Imports a B2BOptic XML document as a new session, which is assigned to an existing patient via Patient id. If the patient does not exist with the given patient id, a new patient is created and the new session is associated accordingly.


## Documentation for Models

 - [Model.B2BOptic](docs/B2BOptic.md)
 - [Model.PageInfo](docs/PageInfo.md)
 - [Model.PaginationLink](docs/PaginationLink.md)
 - [Model.PaginationLinkNext](docs/PaginationLinkNext.md)
 - [Model.Patient](docs/Patient.md)
 - [Model.PatientFilter](docs/PatientFilter.md)
 - [Model.PatientLink](docs/PatientLink.md)
 - [Model.PatientLinkPatient](docs/PatientLinkPatient.md)
 - [Model.PatientLinkSelf](docs/PatientLinkSelf.md)
 - [Model.PatientResponse](docs/PatientResponse.md)
 - [Model.PatientResponseAllOf](docs/PatientResponseAllOf.md)
 - [Model.PatientsResponse](docs/PatientsResponse.md)
 - [Model.Session](docs/Session.md)
 - [Model.SessionFilter](docs/SessionFilter.md)
 - [Model.SessionLink](docs/SessionLink.md)
 - [Model.SessionLinkB2bOptic](docs/SessionLinkB2bOptic.md)
 - [Model.SessionLinkPatient](docs/SessionLinkPatient.md)
 - [Model.SessionLinkSession](docs/SessionLinkSession.md)
 - [Model.SessionResponse](docs/SessionResponse.md)
 - [Model.SessionResponseAllOf](docs/SessionResponseAllOf.md)
 - [Model.SessionState](docs/SessionState.md)
 - [Model.SessionsResponse](docs/SessionsResponse.md)


## Documentation for Authorization

All endpoints do not require authorization.

## Author

cnxt@rodenstock.com

